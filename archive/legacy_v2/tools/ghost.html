<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Ghost Engine | Active Memory</title>
        <style>
            :root {
                --bg-color: #1a1a1a;
                --card-bg: #2d2d2d;
                --accent: #0078d4;
                --text: #ffffff;
                --success: #4caf50;
                --error: #f44336;
            }

            body {
                font-family: "Segoe UI", system-ui, sans-serif;
                background-color: var(--bg-color);
                color: var(--text);
                margin: 0;
                padding: 20px;
                height: 10vh;
                overflow: auto;
            }

            .header {
                text-align: center;
                margin-bottom: 30px;
            }

            .status-indicator {
                display: inline-block;
                padding: 8px 16px;
                border-radius: 20px;
                margin-left: 10px;
                font-size: 0.9em;
            }

            .connected {
                background-color: rgba(76, 175, 80, 0.2);
                color: var(--success);
            }

            .disconnected {
                background-color: rgba(244, 67, 54, 0.2);
                color: var(--error);
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
            }

            .controls {
                display: flex;
                gap: 15px;
                margin-bottom: 20px;
                flex-wrap: wrap;
            }

            button {
                background-color: var(--accent);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 500;
            }

            button:hover {
                opacity: 0.9;
            }

            button:disabled {
                background-color: #555;
                cursor: not-allowed;
            }

            .log-container {
                background-color: var(--card-bg);
                border-radius: 8px;
                padding: 15px;
                height: 400px;
                overflow-y: auto;
                font-family: monospace;
                font-size: 0.9em;
                border: 1px solid #333;
            }

            .log-entry {
                margin-bottom: 5px;
                padding: 5px;
                border-radius: 4px;
            }

            .log-info {
                color: #aaa;
            }
            .log-success {
                color: var(--success);
            }
            .log-error {
                color: var(--error);
            }
            .log-warning {
                color: #ff9800;
            }

            .stats {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin-top: 20px;
            }

            .stat-card {
                background-color: var(--card-bg);
                border-radius: 8px;
                padding: 15px;
                text-align: center;
                border: 1px solid #333;
            }

            .stat-value {
                font-size: 2em;
                font-weight: bold;
                color: var(--accent);
                margin: 10px 0;
            }

            .stat-label {
                color: #aaa;
                font-size: 0.9em;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>ðŸ‘» Ghost Engine | Active Memory</h1>
                <p>
                    Database operations run in your browser when this page is
                    open
                </p>
                <div
                    id="connection-status"
                    class="status-indicator disconnected"
                >
                    DISCONNECTED
                </div>
            </div>

            <div class="controls">
                <button id="connect-btn">Connect to Bridge</button>
                <button id="init-db-btn" disabled>Initialize Database</button>
                <button id="test-query-btn" disabled>Test Query</button>
                <button id="reload-db-btn" disabled>Reload Database</button>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Documents</div>
                    <div id="doc-count" class="stat-value">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Memory Relations</div>
                    <div id="memory-relations" class="stat-value">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Last Activity</div>
                    <div id="last-activity" class="stat-value">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Status</div>
                    <div id="engine-status" class="stat-value">Idle</div>
                </div>
            </div>

            <h3>Operation Log</h3>
            <div id="log" class="log-container"></div>
        </div>

        <!-- CozoDB WASM Module -->
        <script src="cozo_lib_wasm.js"></script>

        <script type="module">
            import initCozo, { CozoDb } from "./cozo_lib_wasm.js";

            // Configuration
            const PORT = 3000;

            // Global variables
            let socket = null;
            let db = null;
            let isConnected = false;

            // DOM Elements
            const connectBtn = document.getElementById("connect-btn");
            const initDbBtn = document.getElementById("init-db-btn");
            const testQueryBtn = document.getElementById("test-query-btn");
            const reloadDbBtn = document.getElementById("reload-db-btn");
            const connectionStatus =
                document.getElementById("connection-status");
            const logContainer = document.getElementById("log");
            const docCountEl = document.getElementById("doc-count");
            const engineStatus = document.getElementById("engine-status");
            const memoryRelationsEl =
                document.getElementById("memory-relations");
            const lastActivityEl = document.getElementById("last-activity");

            // Logging function
            function log(level, message) {
                const timestamp = new Date().toISOString().slice(11, 19);
                const logEntry = document.createElement("div");
                logEntry.className = `log-entry log-${level.toLowerCase()}`;
                logEntry.textContent = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;

                // Send to global log viewer for debugging
                try {
                    const logChannel = new BroadcastChannel('sovereign-logs');
                    logChannel.postMessage({
                        source: 'Ghost Engine',
                        time: new Date().toISOString(),
                        type: level.toLowerCase(),
                        msg: message
                    });
                } catch (e) {
                    console.warn('Could not send log to broadcast channel:', e);
                }
            }

            // Initialize database
            async function initDatabase() {
                try {
                    log("INFO", "Initializing CozoDB...");

                    // Initialize WASM module
                    await initCozo();
                    log("SUCCESS", "WASM Module loaded");

                    // Create database instance with persistent storage
                    try {
                        db = await CozoDb.new_from_indexed_db(
                            "coda_memory_v2",
                            "cozo_store",
                            () => {},
                        );
                        log("SUCCESS", "CozoDB (Persistent) Loaded [v2]");
                    } catch (e) {
                        log(
                            "WARNING",
                            "Persistence failed, using memory: " + e.message,
                        );
                        db = CozoDb.new();
                    }

                    // Ensure schema exists
                    const schemaOk = await ensureSchema();
                    if (!schemaOk) {
                        log("ERROR", "Schema creation failed, database not ready");
                        return false;
                    }

                    // Update stats
                    await updateStats();

                    log("SUCCESS", "Database initialized successfully");
                    return true;
                } catch (e) {
                    log(
                        "ERROR",
                        "Database initialization failed: " + e.message,
                    );
                    return false;
                }
            }

            // Ensure database schema
            async function ensureSchema() {
                // Create basic table first
                const basicSchemaQuery = `:create memory {id: String => timestamp: Int, content: String, source: String, type: String} if not exists;`;

                try {
                    const result = await db.run(basicSchemaQuery, "{}");
                    const jsonResult = JSON.parse(result);

                    if (jsonResult.ok) {
                        log("SUCCESS", "Basic schema created successfully");
                    } else {
                        log(
                            "ERROR",
                            "Basic schema creation failed: " +
                                JSON.stringify(jsonResult.error || "Unknown error"),
                        );
                        return false;
                    }
                } catch (e) {
                    log("ERROR", "Basic schema operation failed: " + (e.message || "Unknown error"));
                    return false;
                }

                // Then, try to create FTS separately
                const ftsQuery = `::fts create memory:content_fts {extractor: content, tokenizer: Simple, filters: [Lowercase]} if not exists;`;

                try {
                    const ftsResult = await db.run(ftsQuery, "{}");
                    const ftsJsonResult = JSON.parse(ftsResult);

                    if (ftsJsonResult.ok) {
                        log("SUCCESS", "FTS index created successfully");
                    } else {
                        log(
                            "WARNING",
                            "FTS creation failed (search will be limited): " +
                                JSON.stringify(ftsJsonResult.error || "Unknown error"),
                        );
                        // Don't return false here - basic functionality still works
                    }
                } catch (e) {
                    log(
                        "WARNING",
                        "FTS creation failed (search will be limited): " + (e.message || "Unknown error")
                    );
                    // Don't return false - basic functionality still works
                }

                return true;
            }

            // Update statistics display
            async function updateStats() {
                try {
                    const countQuery = "?[count(id)] := *memory{id}";
                    const result = await db.run(countQuery, "{}");
                    const jsonResult = JSON.parse(result);

                    if (
                        jsonResult.ok &&
                        jsonResult.rows &&
                        jsonResult.rows[0]
                    ) {
                        docCountEl.textContent = jsonResult.rows[0][0];
                    } else {
                        docCountEl.textContent = "0";
                    }

                    // Update other stats as needed
                    memoryRelationsEl.textContent = "memory";
                    lastActivityEl.textContent =
                        new Date().toLocaleTimeString();
                } catch (e) {
                    docCountEl.textContent = "Error";
                    log("ERROR", "Failed to get document count: " + e.message);
                }
            }

            // Connect to bridge
            function connectToBridge() {
                if (socket) {
                    socket.close();
                }

                const wsUrl = `ws://localhost:${PORT}/ws/chat`;
                log("INFO", "Connecting to Bridge at: " + wsUrl);

                try {
                    socket = new WebSocket(wsUrl);

                    socket.onopen = async () => {
                        log("SUCCESS", "Connected to Bridge");
                        isConnected = true;
                        connectionStatus.textContent = "CONNECTED";
                        connectionStatus.className =
                            "status-indicator connected";

                        // Initialize database first before signaling readiness
                        const dbInitialized = await initDatabase();
                        if (dbInitialized) {
                            // Send ready message to bridge only after database is ready
                            socket.send(JSON.stringify({ type: "engine_ready" }));
                            log("SUCCESS", "Ghost Engine Ready - Database initialized and ready for requests");
                        } else {
                            log("ERROR", "Database initialization failed, Ghost Engine not ready");
                            socket.send(JSON.stringify({
                                type: "engine_error",
                                message: "Database initialization failed"
                            }));
                        }

                        // Enable buttons
                        initDbBtn.disabled = false;
                        testQueryBtn.disabled = false;
                        reloadDbBtn.disabled = false;
                    };

                    socket.onmessage = async (event) => {
                        try {
                            const msg = JSON.parse(event.data);

                            if (msg.type === "engine_ready") {
                                log(
                                    "INFO",
                                    "Bridge acknowledged engine readiness",
                                );
                            } else if (msg.type === "engine_error") {
                                log(
                                    "ERROR",
                                    "Bridge reported engine error: " + (msg.message || "Unknown error"),
                                );
                            } else if (
                                msg.type === "memory_ingest" ||
                                msg.type === "ingest"
                            ) {
                                // Only process ingest if database is ready
                                if (db) {
                                    await handleIngest(msg);
                                } else {
                                    log("WARNING", "Received ingest request but database not ready, queuing for later");
                                    // For now, send an error back - in a more advanced implementation we could queue these
                                    if (msg.id && socket && socket.readyState === WebSocket.OPEN) {
                                        socket.send(
                                            JSON.stringify({
                                                id: msg.id,
                                                type: "ingest_complete",
                                                status: "error",
                                                error: "Database not ready, please wait for initialization to complete",
                                            }),
                                        );
                                    }
                                }
                            } else if (msg.type === "direct_search_request") {
                                // Only process search if database is ready
                                if (db) {
                                    await handleSearch(msg);
                                } else {
                                    log("WARNING", "Received search request but database not ready");
                                    if (msg.id && socket && socket.readyState === WebSocket.OPEN) {
                                        socket.send(
                                            JSON.stringify({
                                                type: "direct_search_result",
                                                id: msg.id,
                                                result: "Database not ready, please wait for initialization to complete",
                                            }),
                                        );
                                    }
                                }
                            } else {
                                log(
                                    "INFO",
                                    "Received message type: " + msg.type,
                                );
                            }
                        } catch (e) {
                            log(
                                "ERROR",
                                "Error processing message: " + e.message,
                            );
                        }
                    };

                    socket.onclose = () => {
                        log("WARNING", "Bridge connection closed");
                        isConnected = false;
                        connectionStatus.textContent = "DISCONNECTED";
                        connectionStatus.className =
                            "status-indicator disconnected";

                        // Disable buttons
                        initDbBtn.disabled = true;
                        testQueryBtn.disabled = true;
                        reloadDbBtn.disabled = true;
                    };

                    socket.onerror = (error) => {
                        log(
                            "ERROR",
                            "Bridge connection error: " + error.message,
                        );
                    };
                } catch (e) {
                    log(
                        "ERROR",
                        "Failed to create WebSocket connection: " + e.message,
                    );
                }
            }

            // Handle memory ingestion
            async function handleIngest(msg) {
                log(
                    "INFO",
                    `Processing ingest request: ${msg.filename || "unnamed"}`,
                );

                // Check if database is initialized
                if (!db) {
                    const errorMsg = "Database not initialized, cannot process ingest request";
                    log("ERROR", errorMsg);

                    // Send error acknowledgment if ID exists
                    if (
                        msg.id &&
                        socket &&
                        socket.readyState === WebSocket.OPEN
                    ) {
                        socket.send(
                            JSON.stringify({
                                id: msg.id,
                                type: "ingest_complete",
                                status: "error",
                                error: errorMsg,
                            }),
                        );
                    }
                    return;
                }

                try {
                    const id = `doc_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                    const timestamp = Date.now();

                    // Prepare the insert query
                    const query = `:insert memory {id, timestamp, content, source, type} <- $data`;
                    const params = {
                        data: [
                            [
                                id,
                                timestamp,
                                msg.content,
                                msg.source || msg.filename || "unknown",
                                msg.file_type || "text",
                            ],
                        ],
                    };

                    const result = await db.run(query, JSON.stringify(params));
                    const jsonResult = JSON.parse(result);

                    if (jsonResult.ok) {
                        log("SUCCESS", `Ingested document: ${id}`);

                        // Update stats
                        await updateStats();

                        // Send completion acknowledgment if ID exists
                        if (
                            msg.id &&
                            socket &&
                            socket.readyState === WebSocket.OPEN
                        ) {
                            socket.send(
                                JSON.stringify({
                                    id: msg.id,
                                    type: "ingest_complete",
                                    status: "success",
                                    doc_id: id,
                                }),
                            );
                        }
                    } else {
                        log(
                            "ERROR",
                            `Ingest failed: ${JSON.stringify(jsonResult.error || "Unknown error")}`,
                        );

                        // Send error acknowledgment if ID exists
                        if (
                            msg.id &&
                            socket &&
                            socket.readyState === WebSocket.OPEN
                        ) {
                            socket.send(
                                JSON.stringify({
                                    id: msg.id,
                                    type: "ingest_complete",
                                    status: "error",
                                    error: jsonResult.error || "Unknown error",
                                }),
                            );
                        }
                    }
                } catch (e) {
                    log("ERROR", `Ingest error: ${e.message || "Unknown error"}`);

                    // Send error acknowledgment if ID exists
                    if (
                        msg.id &&
                        socket &&
                        socket.readyState === WebSocket.OPEN
                    ) {
                        socket.send(
                            JSON.stringify({
                                id: msg.id,
                                type: "ingest_complete",
                                status: "error",
                                error: e.message || "Unknown error",
                            }),
                        );
                    }
                }
            }

            // Handle search requests
            async function handleSearch(msg) {
                log("INFO", `Processing search request: ${msg.query}`);

                try {
                    const limit = msg.limit || 10;
                    let results = [];

                    // 1. Try FTS (Full Text Search) first
                    try {
                        const ftsQuery = `?[source, content, score] := ~memory:content_fts{content | query: $q, score: s}, score = s :order -score :limit $limit`;
                        const ftsResult = await db.run(
                            ftsQuery,
                            JSON.stringify({ q: msg.query, limit: limit * 2 }),
                        ); // Get more for diversity
                        const ftsJson = JSON.parse(ftsResult);

                        if (ftsJson.ok && ftsJson.rows) {
                            for (const row of ftsJson.rows) {
                                // Only add if not already in results (by source)
                                if (!results.some((r) => r[0] === row[0])) {
                                    results.push([row[0], row[1]]); // source, content (skip score in final result)
                                }
                            }
                        }
                    } catch (e) {
                        log("WARNING", `FTS search failed: ${e.message}`);
                    }

                    // 2. Fallback to regex search if FTS didn't return enough results
                    if (results.length < Math.min(5, limit)) {
                        try {
                            const regexQuery = `?[source, content] := *memory{source, content}, regex_matches($q, content) :limit $limit`;
                            const regexResult = await db.run(
                                regexQuery,
                                JSON.stringify({ q: msg.query, limit: limit }),
                            );
                            const regexJson = JSON.parse(regexResult);

                            if (regexJson.ok && regexJson.rows) {
                                for (const row of regexJson.rows) {
                                    // Only add if not already in results
                                    if (!results.some((r) => r[0] === row[0])) {
                                        results.push(row);
                                    }
                                }
                            }
                        } catch (e) {
                            log("WARNING", `Regex search failed: ${e.message}`);
                        }
                    }

                    // 3. If still not enough results, try source name matching
                    if (results.length < Math.min(3, limit)) {
                        try {
                            const sourceQuery = `?[source, content] := *memory{source, content}, regex_matches($q, source) :limit $limit`;
                            const sourceResult = await db.run(
                                sourceQuery,
                                JSON.stringify({ q: msg.query, limit: limit }),
                            );
                            const sourceJson = JSON.parse(sourceResult);

                            if (sourceJson.ok && sourceJson.rows) {
                                for (const row of sourceJson.rows) {
                                    // Only add if not already in results
                                    if (!results.some((r) => r[0] === row[0])) {
                                        results.push(row);
                                    }
                                }
                            }
                        } catch (e) {
                            log(
                                "WARNING",
                                `Source search failed: ${e.message}`,
                            );
                        }
                    }

                    // Format results as markdown
                    let output = "";
                    let charCount = 0;
                    const maxChars = msg.max_chars || 10000;

                    for (const [source, content] of results) {
                        if (charCount + content.length > maxChars) break;
                        output += `### Source: ${source}\n${content}\n\n`;
                        charCount += content.length;
                    }

                    if (!output) output = "No relevant context found.";

                    // Send results back to bridge
                    if (
                        msg.id &&
                        socket &&
                        socket.readyState === WebSocket.OPEN
                    ) {
                        socket.send(
                            JSON.stringify({
                                type: "direct_search_result",
                                id: msg.id,
                                result: output,
                            }),
                        );
                    }

                    log(
                        "SUCCESS",
                        `Search completed, found ${results.length} results`,
                    );
                } catch (e) {
                    log("ERROR", `Search error: ${e.message}`);

                    // Send error result back to bridge
                    if (
                        msg.id &&
                        socket &&
                        socket.readyState === WebSocket.OPEN
                    ) {
                        socket.send(
                            JSON.stringify({
                                type: "direct_search_result",
                                id: msg.id,
                                result: `Search error: ${e.message}`,
                            }),
                        );
                    }
                }
            }

            // Test query function
            async function testQuery() {
                if (!db) {
                    log("ERROR", "Database not initialized");
                    return;
                }

                try {
                    log("INFO", "Running test query...");
                    const query = "?[count(id)] := *memory{id}";
                    const result = await db.run(query, "{}");
                    const jsonResult = JSON.parse(result);

                    if (jsonResult.ok) {
                        if (jsonResult.rows && jsonResult.rows[0]) {
                            log(
                                "SUCCESS",
                                `Test query successful: ${jsonResult.rows[0][0]} documents in memory`,
                            );
                        } else {
                            log(
                                "SUCCESS",
                                "Test query successful: 0 documents in memory",
                            );
                        }
                    } else {
                        log(
                            "ERROR",
                            `Test query failed: ${JSON.stringify(jsonResult.error || "Unknown error")}`,
                        );
                    }
                } catch (e) {
                    log("ERROR", `Test query error: ${e.message || "Unknown error"}`);
                }
            }

            // Event listeners
            connectBtn.addEventListener("click", connectToBridge);

            initDbBtn.addEventListener("click", async () => {
                await initDatabase();
                await updateStats();
            });

            testQueryBtn.addEventListener("click", testQuery);

            reloadDbBtn.addEventListener("click", async () => {
                log("INFO", "Reloading database...");
                if (db) {
                    db.free(); // Free the current database instance
                }
                const success = await initDatabase();
                if (success) {
                    await updateStats();
                }
            });

            // Initialize on load
            window.addEventListener("load", () => {
                log(
                    "INFO",
                    'Ghost Engine UI loaded. Click "Connect to Bridge" to begin.',
                );
            });
        </script>
    </body>
</html>
